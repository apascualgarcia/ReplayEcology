install.packages("RbioRXN")
library(phyloseq)
superimp = kabsch_R(Q, P) # Find optimal rotation
library(phyloseq)
library(reshape2)
#library(RDPutils)
library(ggplot2)
library(usedist)
library(plyr)
# START EDITING -----------
# --- Set the files needed
file.meta = "metadata_Time0D-7D-4M_May2022_wJSDpart-merged.csv" # metadata with partitions
file.meta.out = "metadata_Time0D-7D-4M_May2022_wJSDpart-merged_ext.csv" # new metadata with combinations of columns
fileOTU = "seqtable_readyforanalysis.csv" # ASVs table
fileTaxonomy = "taxa_wsp_readyforanalysis.csv" # taxonomy
fileDist = "Dist_JSD_Time0D-7D-4M.RDS" # beta diversity distance
# select if matched or total dataset, will be processed below
set="matched" #"matched" # or all
# select the name of the partition to create the barplots
sel_partition = "Time0D.7D.matched" # defaults to "partition", which is the clustering of each set made independently
# the factor selected will override "partition"
# select how points in the pcoa will be differentiated
colorby="partition" # "exp.partition" # "partition" "parent" "Location" replicate.partition
# --- Set the main directory
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1]
dirSrc=paste(this.dir,"/src/",sep="") # Directory where the code is
#dirSrc=here::here() # src of the repository
setwd(dirSrc)
#  --- Load metadata
setwd("../7.1_classes")
sample_metadata <- import_qiime_sample_data(file.meta) #read.table(file.meta,sep="\t",header=TRUE)
sample_metadata[, "partition"] = sample_metadata[, sel_partition]
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/merge_metadata.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/main_find_classes.R", echo=TRUE)
out_classes=otu_table_to_classes(t(ASV.table),Nclus = 25,
distance = data.dist, euclidean = T)
setwd("../7.1_classes")
fileDist="Dist_JSD_Time0D-7D-4M.RDS"
data.dist=readRDS(fileDist)
rm(list=ls())
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1]
dirSrc=paste(this.dir,"/src/",sep="") # Directory where the code is
#dirSrc=here::here() # src of the repository
setwd(dirSrc)
source("pam.clustering.R")
source("dist.JSD.R")
source("otu_table_to_classes.R")
source("plot_calinski.R")
source("clustering_to_partition.R")
source("indexG1.check.R")
source("dist_to_pcoa.R")
####### START EDITING
# Set parameters -------
nreads = 10000 # minimum number of reads to consider a sample
# ... First time should be set to true to compute the JSD matrix which is
#     computationally costly. Subsequent runs just fix to FALSE to skip it
#     and read from file. If set to TRUE, not includes or excludes are allowed.
compute.dist = FALSE
exclude_exp = c() # A vector of characters with the experiments that should be excluded
match_exp = FALSE # Set to true if only starting communities that were resurrected should be included
output.label = "Time0D_7D_4M"
# Read files ------------
# --- Read ASVs table
setwd("../6_finalfiles")
fileOTU="seqtable_readyforanalysis.csv"
ASV.table=read.table(fileOTU,sep="\t")
# ..... read metadata. Samples present in metadata were those passing the filtering
setwd("../4_dada2/")
fileMD="metadata_Time0D-7D-4M_May2022.csv"
sample_md<-read.table(fileMD,sep="\t",header=TRUE)
# .... read distance if already available
if(compute.dist == FALSE){
setwd("../7.1_classes")
fileDist="Dist_JSD_Time0D-7D-4M.RDS"
data.dist=readRDS(fileDist)
}
# Clean data   ------
ASV.table=ASV.table[,colSums(ASV.table) > 0]
ASV.table=ASV.table[rowSums(ASV.table) > nreads, ]
which(is.na(ASV.table))
# .... exclude samples that didn't pass quality control (not present in samples metadata)
matched=match(row.names(ASV.table),sample_md$sampleid) #attr(data.dist,"Labels"))
ASV.table=ASV.table[!is.na(matched),]
dim(ASV.table)
# ... double check that is ordered as the ASV table
matched = match(rownames(ASV.table), names(data.dist))
which(is.na(matched))  # none
dim(as.matrix(data.dist)) # 4 more elements
data.dist.tmp=as.dist(as.matrix(data.dist)[matched, matched])
data.dist = data.dist.tmp # same here
dim(as.matrix(data.dist)) # 4 more elements
# ... rebuild the metadata, it may have more samples
matched=match(row.names(ASV.table),sample_md$sampleid)
matched=matched[!is.na(matched)]
sample_md = sample_md[matched, ]
exclude_exp
match_exp
# Exclude data ----
if((length(exclude_exp) != 0) | (match_exp == TRUE)){
sample_md_red = sample_md
if(length(exclude_exp) != 0){ # exclude experiments
for(level in exclude_exp){
idx=which(sample_md_red$Experiment != level)
sample_md_red = sample_md_red[idx, ]
}
}
if(match_exp == TRUE){ # exclude communities that were not resurrected
nchild = table(sample_md_red$parent)
idx = which(nchild == 5)
matched = match(sample_md_red$parent, names(nchild)[idx])
sample_md_red = sample_md_red[!is.na(matched), ]
}
sample_md = sample_md_red #
# ... look for the positions of remaining samples
matched=match(sample_md$sampleid,row.names(ASV.table))
matched=matched[!is.na(matched)]
# ... reshape objects
ASV.tmp=ASV.table[matched,] # this tmp file is unnecessary, but easier to debug
dim(ASV.tmp)
ASV.table = ASV.tmp # this tmp file is unnecessary, but easier to debug
if(compute.dist == FALSE){
data.dist.tmp=as.dist(as.matrix(data.dist)[matched, matched])
data.dist = data.dist.tmp # same here
}
ASV.table=ASV.table[,colSums(ASV.table) > 0]
# ... rebuild the metadata, it may have more samples
matched=match(row.names(ASV.table),sample_md$sampleid)
matched=matched[!is.na(matched)]
sample_md = sample_md[matched, ]
}
out_classes=otu_table_to_classes(t(ASV.table),Nclus = 25,
distance = data.dist, euclidean = T)
# .... Extract objects
nclusters = out_classes$nclusters
Kmax = which.max(nclusters)
# .... Plot results
setwd("../7.1_classes")
filename="Plot_PAM-IndexG1_orig-medoidsV2"
plot_calinski(nclusters,
filename = filename,
outputlabel = output.label) # check the maxima
# .... Extract partition
partition=clustering_to_partition(data.dist,Kmax = Kmax,
outputlabel = output.label,
print.file = TRUE)
sample_md[, output.label] = partition[,"PartId"]
# .... Print output
fileOut=unlist(strsplit(fileMD,".",fixed=T))[1]
fileOut=paste0(fileOut,"_",output.label,"_wJSDpart-all.csv")
write.table(sample_md,file = fileOut,sep="\t",quote=F,row.names = F)
which(data.dist == NA)
which(is.na(data.dist))
which(is.na(data.dist) == T)
which((data.dist) <= 0)
max(data.dist)
min(data.dist)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/main_find_classes.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/main_find_classes.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/main_find_classes.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/merge_metadata.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/merge_metadata.R", echo=TRUE)
debugSource("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/phyloseq_analysis.R", echo=TRUE)
Npart = length(levels(treeholes.rar@sam_data$partition))
usecolor=colorCodes[Npart]
usecolor=colorCodes[1:Npart]
colorlab="Class"
# ... prepare labels
labfacets=c("Starting communities","Final, Replicate 1","Final, Replicate 2",
"Final, Replicate 3","Final, Replicate 4")
names(labfacets)=c("Rep0","Rep1","Rep2","Rep3","Rep4")
axesby=c(1,2)
labaxes="Axes1-2"
explainX = round(treeholes.ord$values[axesby[1],2] * 100, digits = 2)
explainY = round(treeholes.ord$values[axesby[2],2]* 100, digits = 2)
xlab = paste0("PCoA, component ", axesby[1]," [",explainX,"%]")
ylab = paste0("PCoA, component ", axesby[2]," [",explainY,"%]")
# ... prepare plot
plotTitle=paste("Plot",method,"_",dist,"_Par",sel_partition,"_By",colorby,"_",labelOut,"_",labaxes,".pdf",sep="")
pdf(file=plotTitle,width=22,height=6)
title=paste(method," of ",dist," distance",sep="")
treeholes.ord$vectors[, "Axis.2"] = -1*treeholes.ord$vectors[, "Axis.2"]
# ... plot
p = plot_ordination(treeholes.rar, treeholes.ord, color = colorby,
axes=axesby) #,label="parent")#,shape="partition")
p = p + geom_point(size = 4.0, alpha = 0.7) + ggtitle(title)+
labs(color = colorlab)+xlab(xlab)+ylab(ylab)+
theme_bw()+
theme(axis.title = element_text(size=24),
title=element_blank(), #element_text(size=16),
axis.text=element_text(size=20),
strip.text=element_text(size=22),
legend.title = element_text(size=22),
legend.text=element_text(size=20))
p + facet_wrap(~replicate,nrow=1,ncol=5,
labeller=labeller(replicate=labfacets))+
scale_color_manual(values = usecolor) #scale_color_hue()# scale_color_brewer(palette="Accent")
dev.off()
View(sample_metadata)
#  --- Load metadata
setwd("../7.1_classes")
sample_metadata <- import_qiime_sample_data(file.meta) #read.table(file.meta,sep="\t",header=TRUE)
rm(list=ls())
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1]
dirSrc=paste(this.dir,"/src/",sep="") # Directory where the code is
setwd(dirSrc)
setwd("../7.1_classes")
fileIn1 = "metadata_Time0D-7D-4M_May2022_wJSDpart-split.csv"
sample_md1 = read.table(fileIn1, sep="\t", header = T) # this will be the reference
fileIn2 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_4M_wJSDpart-all.csv"
sample_md2 = read.table(fileIn2,sep="\t", header = T)
fileIn3 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_wJSDpart-all.csv"
sample_md3 = read.table(fileIn3, sep="\t", header = T)
fileIn4 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_matched_wJSDpart-all.csv"
sample_md4 = read.table(fileIn4, sep="\t", header = T)
fileOut = "metadata_Time0D-7D-4M_May2022_wJSDpart-merged.csv"
sample_md = merge(sample_md1, sample_md2, all.x = T)
View(sample_md)
View(sample_md2)
View(sample_md)
View(sample_md1)
?merge
intersect(names(sample_md1), names(sample_md2))
sample_md = merge(sample_md1, sample_md2, by = "parent", all.x = T)
View(sample_md)
sample_md = merge(sample_md1, sample_md2, by = "sampleid", all.x = T)
View(sample_md)
sample_md = merge(sample_md1, sample_md2) #, by = "sampleid", all.x = T)
View(sample_md)
View(sample_md2)
2156/4
rm(list=ls())
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1]
dirSrc=paste(this.dir,"/src/",sep="") # Directory where the code is
setwd(dirSrc)
setwd("../7.1_classes")
fileIn1 = "metadata_Time0D-7D-4M_May2022_wJSDpart-split.csv"
sample_md1 = read.table(fileIn1, sep="\t", header = T) # this will be the reference
fileIn2 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_4M_wJSDpart-all.csv"
sample_md2 = read.table(fileIn2,sep="\t", header = T)
fileIn3 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_wJSDpart-all.csv"
sample_md3 = read.table(fileIn3, sep="\t", header = T)
fileIn4 = "metadata_Time0D-7D-4M_May2022_Time0D_7D_matched_wJSDpart-all.csv"
sample_md4 = read.table(fileIn4, sep="\t", header = T)
fileOut = "metadata_Time0D-7D-4M_May2022_wJSDpart-merged.csv"
sample_md = sample_md1
# ... add first partition
sample_md$Time0D_7D_4M = NA
matched = match(sample_md2$sampleid, sample_md$sampleid)
sample_md$Time0D_7D_4M[matched] = sample_md2$Time0D_7D_4M
# ... second
sample_md$Time0D_7D = NA
matched = match(sample_md3$sampleid, sample_md$sampleid)
sample_md$Time0D_7D[matched] = sample_md3$Time0D_7D
# ... third
sample_md$Time0D_7D_matched = NA
matched = match(sample_md4$sampleid, sample_md$sampleid)
sample_md$Time0D_7D_matched[matched] = sample_md4$Time0D_7D_matched
# Write output -----
write.table(sample_md, file = fileOut, sep = "\t", quote = F)
# Check differences between partitions
part_diff = sample_md$Part_Time7D_rep1_2 - sample_md$Time0D.7D.matched
part_diff = part_diff[!is.na(part_diff)]
length(which(part_diff == 1)) # 15
length(which(part_diff == -1)) # 15
# Check differences between partitions
part_diff = sample_md$Part_Time7D_rep1_2 - sample_md$Time0D_7D_matched
part_diff = part_diff[!is.na(part_diff)]
length(which(part_diff == 1)) # 15
length(which(part_diff == -1)) # 15
part_diff = sample_md$Part_Time7D_rep2_2 - sample_md$Time0D_7D_matched
part_diff = part_diff[!is.na(part_diff)]
length(which(part_diff == 1)) # 11
length(which(part_diff == -1)) # 6
part_diff = sample_md$Part_Time7D_rep3_2 - sample_md$Time0D_7D_matched
part_diff = part_diff[!is.na(part_diff)]
length(which(part_diff == 1)) # 13
length(which(part_diff == -1)) # 3
part_diff = sample_md$Part_Time7D_rep4_2 - sample_md$Time0D_7D_matched
part_diff = part_diff[!is.na(part_diff)]
length(which(part_diff == 1)) # 8
length(which(part_diff == -1)) # 17
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/phyloseq_analysis.R", echo=TRUE)
source("~/Nextcloud/Research/Projects/FunctionalGroups/Repositories/convergence/Partial_Matt_pipeline/src/phyloseq_analysis.R", echo=TRUE)
# .... These are all # (or matched, depending on your choice)
#treeholes.ord = ordinate(treeholes.rar, method=method,distance=dist) #dist.rar)#, "unifrac") # takes more than 1h for JSD
fileOrd=paste0("Ordination_jsd_PCoA_",selected,".RDS")
#saveRDS(treeholes.ord,file=fileOrd)
treeholes.ord=readRDS(fileOrd)
# ......These are only time 0
treeholes.rar.time0=subset_samples(treeholes.rar,replicate=="Rep0")
if(colorby=="partition"){
Npart = length(levels(treeholes.rar@sam_data$partition))
usecolor=colorCodes[1:Npart]
colorlab="Class"
}else{
if(colorby == "replicate.partition"){
colorlab="Replicate / Class"
}else if(colorby == "Location"){
colorlab="Location"
}else if(colorby == "exp.partition"){
colorlab="Experiment / Class"
}
usecolor=col_vector
}
# ... prepare labels
labfacets=c("Starting communities","Final, Replicate 1","Final, Replicate 2",
"Final, Replicate 3","Final, Replicate 4")
names(labfacets)=c("Rep0","Rep1","Rep2","Rep3","Rep4")
axesby=c(1,2)
labaxes="Axes1-2"
explainX = round(treeholes.ord$values[axesby[1],2] * 100, digits = 2)
explainY = round(treeholes.ord$values[axesby[2],2]* 100, digits = 2)
xlab = paste0("PCoA, component ", axesby[1]," [",explainX,"%]")
ylab = paste0("PCoA, component ", axesby[2]," [",explainY,"%]")
# ... prepare plot
plotTitle=paste("Plot",method,"_",dist,"_Par",sel_partition,"_By",colorby,"_",labelOut,"_",labaxes,".pdf",sep="")
pdf(file=plotTitle,width=22,height=6)
title=paste(method," of ",dist," distance",sep="")
treeholes.ord$vectors[, "Axis.2"] = -1*treeholes.ord$vectors[, "Axis.2"]
# ... plot
p = plot_ordination(treeholes.rar, treeholes.ord, color = colorby,
axes=axesby) #,label="parent")#,shape="partition")
p = p + geom_point(size = 4.0, alpha = 0.7) + ggtitle(title)+
labs(color = colorlab)+xlab(xlab)+ylab(ylab)+
theme_bw()+
theme(axis.title = element_text(size=24),
title=element_blank(), #element_text(size=16),
axis.text=element_text(size=20),
strip.text=element_text(size=22),
legend.title = element_text(size=22),
legend.text=element_text(size=20))
p + facet_wrap(~replicate,nrow=1,ncol=5,
labeller=labeller(replicate=labfacets))+
scale_color_manual(values = usecolor) #scale_color_hue()# scale_color_brewer(palette="Accent")
dev.off()
